//User Data
Table user {
  id integer [primary key, increment]
  default_token_id int
  username varchar unique
  salted_password varchar [note: "????? not sure not yet"]
  personal_data_id integer
}

table personal_data {
  id integer [primary key, increment]
  full_name varchar
  email varchar
  school_id integer
  created_at timestamp
}
ref: personal_data.id - user.personal_data_id

table school {
  id integer [primary key, increment]
  name varchar
  created_at timestamp
}
Ref: school.id < personal_data.school_id


// Permissions tables
Table role {
  id integer [primary key, increment]
  name varchar
  created_at timestamp
  changed_at timestamp
}

table role_relation {
  id int [primary key, increment]
  role_id int
  parent_role_id int
  child_role_id int
}
Ref: role.id < role_relation.parent_role_id
Ref: role.id < role_relation.child_role_id
Ref: role.id - role_relation.role_id

Table permission {
  id integer [primary key, increment]
  name varchar
  key varchar
  key_object varchar [note: 'Define the object that this key limits. For example: "scoring_criteria"']
}
Ref: role.id < role_permissions.role_id

table role_permissions {
  id integer [primary key, increment]
  permission_id integer
  role_id integer
  key_object_acl jsonb [note: 'Limit defined objects within the key span']
}

table user_role {
  id integer [primary key, increment]
  user_id integer
  role_id integer
  created_at timestamp
}
Ref: permission.id < role_permissions.permission_id
Ref: user.id < user_role.user_id
Ref: role.id < user_role.role_id


// Competition tables
table competition {
  id integer [primary key, increment]
  name varchar
  organizer_id int
  scoring_criteria_group_main_id integer
  start_time time
  end_time time
}
ref: user.id < competition.organizer_id

table competitor {
  id integer [primary key, increment]
  public_display_name_type integer [note: "1 - full_name, 2 - school, 3 - alias"]
  alias varchar [note: "For anonymose alias"]
  personal_data_id integer
}
ref: personal_data.id - competitor.personal_data_id

table competitor_competition {
  id integer
  competitor_id integer
  competition_id integer
}
Ref: competition.id < competitor_competition.competition_id
Ref: competitor.id < competitor_competition.competitor_id

// Allow user to signup
table signup_user {
  id integer [primary key, increment]
  username varchar unique
  salted_password varchar
  personal_data_id int [not null]
  is_approved bool [not null]
  created_at timestamp [not null]
}
ref: personal_data.id < signup_user.personal_data_id

// Basic scoring data tables
table scoring_groups_structure {
  id integer [primary key, increment]
  name varchar
  description text
  competitor_id int
  scoring_parent_group_id integer [note: 'This can be also used to generate api endpoint: https://stackoverflow.com/questions/47341764/self-referencing-table-sql-query']
  structure_group_type int [note: '1 - competition parent, 2 - template, 3 - competitior']
  dynamic_variables jsonb [note: 'To add custom variables that were defined within template and later defined for competitor side.']
}
ref: competitor.id < scoring_groups_structure.competitor_id

table scoring_criteria {
  id integer [primary key, increment]
  scoring_host_id integer
  name varchar [note: 'Give a name to criteria']
  description text [note: 'Custom text to descripe criteria']
  is_manual bool [note: 'If we know a criteria can\'t be done automatically marked this to true.']
  total_points float [note: 'Points to give']
  is_generalized bool [note: "Generlize to specific users during competition timeframe"]
  expected_result text [note: 'What was the data we checked for']
  criteria_template_id int
  is_template bool
  visibility_level int
}
Table criteria_dependency {
  id integer [primary key, increment]
  criteria_id integer
  dependent_on_criteria_id integer
}
ref: scoring_criteria.id < criteria_dependency.criteria_id
ref: scoring_criteria.id < criteria_dependency.dependent_on_criteria_id

table scoring_host {
  id integer [primary key, increment]
  ip varchar
  hostname varchar
  scoring_group_id integer
  host_template_id int
  is_template bool
  is_generalized bool [note: "Generlize to specific users during competition timeframe"]
}
ref: scoring_host.id < scoring_host.host_template_id
ref: scoring_host.id < scoring_criteria.scoring_host_id
Ref: scoring_groups_structure.id < scoring_host.scoring_group_id
Ref: scoring_groups_structure.id - competition.scoring_criteria_group_main_id
Ref: scoring_groups_structure.id < scoring_groups_structure.scoring_parent_group_id

// Create a table for logical groups for scoring
// These are seprate from the strucure
table scoring_logical_groups {
  id integer [primary key, increment]
  name varchar
  is_generalized bool [note: "Generlize to specific users during competition timeframe"]
}
table logical_group_link {
  id integer [primary key, increment]
  logical_group_id int
  scoring_host_id int
  scoring_criteria_id int
}
ref: scoring_logical_groups.id < logical_group_link.logical_group_id
ref: scoring_host.id < logical_group_link.scoring_host_id
ref: scoring_criteria.id < logical_group_link.scoring_criteria_id

// Scoring history
table scoring_history {
  id integer [primary key, increment]
  competitor_id integer
  competition_id integer
  scoring_host_id integer
  scoring_criteria_id integer
  points_given float
  result text
  created_at timestamp
  deleted_at timestamp
  added_by_user_id integer
}
ref: scoring_host.id < scoring_history.scoring_host_id
Ref: user.id < scoring_history.added_by_user_id
Ref: competitor.id < scoring_history.competitor_id
ref: competition.id < scoring_history.competition_id
Ref: scoring_criteria.id < scoring_history.scoring_criteria_id

// Create an api tokens for auth
table api_token {
  id int [primary key, increment]
  user_id int
  name varchar
  token varchar
}
ref: api_token.id - user.default_token_id
ref: user.id < api_token.user_id

// Automatic scoring tables
table scoring_agent {
  id integer [primary key, increment]
  scoring_host_id integer
  scoring_criteria_id integer
  scoring_agent_transport_id integer
  script_id integer
  token_id int
  authentication_type int
  agent_type int [note: '1 - agent push, 2 - server pull, 3 - api only']
  agent_proxy_id int [note: 'Maybe we can deploy a proxy']
  custom_api_endpoint varchar [note: 'possible custom api endpoint']
}
ref: scoring_agent.token_id > api_token.id
ref: scoring_host.id < scoring_agent.scoring_host_id
Ref: scoring_criteria.id < scoring_agent.scoring_criteria_id
table script {
  id integer [primary key, increment]
  name varchar
  type varchar [note: 'powershell, bash etc.']
  script text
}
Ref: script.id < scoring_agent.script_id
table scoring_agent_transport {
  id integer [primary key, increment]
  name varchar [note: 'ssh, http, winrm, bot etc.']
  tcp_port int
  ssh_key varchar [note: 'used for ssh']
}
Ref: scoring_agent_transport.id < scoring_agent.scoring_agent_transport_id

// Agent Proxy server
table agent_proxy {
  id int [primary key, increment]
  ip varchar
  name varchar
  competition_id int
  token_id int [note: 'Will be used for authentication']
  authentication_type int
}
ref: agent_proxy.token_id > api_token.id
ref: competition.id < agent_proxy.competition_id
ref: agent_proxy.id < scoring_agent.agent_proxy_id